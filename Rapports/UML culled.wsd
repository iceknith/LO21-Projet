@startuml UML Akropolis - Culled

abstract class Hexagone {
    # indice_tuile : int
    # texture : image
    # couleur : int [enum Couleur]
    # tuileParent : Tuile*

    + get_texture() : image
    + get_couleur() : int
    + get_tuile() : Tuile*
    + get_local_position() : Vector2
    + peut_etre_placée(map:Map*, position:Vector2) : bool
    + si_recouverte(joueur_qui_la_recouvre:Joueur*)
}

abstract class Carrière extends Hexagone {}

abstract class Place extends Hexagone {
    # etoiles : int

    + get_etoiles() : int
}

abstract class Quartier extends Hexagone {}

class Plateau {
    - Map<int:Hexagone*>

    + obtenir_hexagone(coordonées:Vector2) : Hexagone*
    + peut_placer(tuileJeu:TuileJeu*, position:Vector2) : bool
    + placer(tuileJeu:TuileJeu*, position:Vector2)
}
note left : Est un singleton
Plateau --> "*" Hexagone

abstract class Joueur {
    # pierres : int
    # plateauJoueur : Plateau
    # joueToutSeul: bool

    + place_tuile(tuile:Tuile, coordonées:Vector2) : bool
    + get_score() : int
    + get_pierres() : int
    + set_pierres(pierre:int)
    + get_joue_tout_seul() : bool
    + a_son_tour(chantier:Tuile)
    + ajouter_pierres(pierre:int)
}
Plateau <-- Joueur

class JoueurSimple extends Joueur {
    # ScoreJoueur : Score*
    # joueToutSeul = false

    + get_score() : int
}
JoueurSimple --> Score

class JoueurIllustreArchitecte extends Joueur {
    # niveau : int
    # scoreIllustreArchitechte : ScoreSoloArchitechte*
    # joueToutSeul = true

    + get_score() : int
    + set_niveau(niveau:int)
    + get_niveau() : int
    + a_son_tour(chantier:Tuile)
    # choisir_tuile(chantier:Tuile*) : Tuile
    # trouver_emplacement_tuile() : Vector2
}
JoueurIllustreArchitecte --> ScoreSoloArchitechte


abstract class Tuile {
    - hauteur : int
    - enfants : Hexagone*
    - positions_enfants : Vector2*
    - nombre_enfants : int

    + set_hauteur(hauteur:int)
    + get_hauteur() : int
    + get_enfants() : Hexagone*
    + get_position_enfants() : Vector2*
    + get_nombre_enfants() : Vector2
}
Tuile <--> Hexagone

abstract class TuileDépart extends Tuile {}

abstract class TuileJeu extends Tuile {}


abstract class Score {
    # scoreDécoré : Score*
    + score(Plateau*) : int 
}
note left : Est un décorateur

abstract class ScoreSoloArchitechte extends Score {
    # niveau : int
    + set_niveau(niveau:int)
    + get_niveau() : int
}

class Deck {
    - taille : int
    - tuiles : Tuile*

    + set_nombre_joueurs(nombre_joueurs:int)
    + set_taille(taille:int)
    + get_taille() : int
    + obtenir_tuile() : Tuile
    + obtenir_tuile(nombre:int) : Tuile*
}
Deck --> Tuile

class Chantier {
    - taille : int
    - tuiles : Tuile*

    + set_nombre_joueurs(nombre_joueurs:int)
    + set_taille(taille:int)
    + get_taille() : int
    + get_tuiles() : Tuile*
    + obtenir_tuile(index:int)
    + ajouter_tuile(tuile:Tuile)
    + ajouter_tuile(tuile:Tuile*, nombre:int)
}
Chantier --> Tuile

class Jeu {
    # nombre_joueurs : int
    # joueurs : Joueur*
    # deck : Deck*
    # chantier : Chantier*
    # affichage : Affichage*


}
note right : Est un singleton
Jeu --> Joueur
Jeu --> Deck
Jeu --> Chantier
Jeu --> Affichage

abstract class Affichage {
    + affichePlateauActuel(joueur : Joueur*, chantier : Chantier*, deck : Deck*)
}

class AffichageConsole extends Affichage {

}
note right : Est un singleton

class AffichageGUI extends Affichage {

}
note left : Est un singleton

@enduml